:ruby
  element_style ||= nil
  q             ||= @q || {}
  style = " left:  #{layout.x}px;"      + 
          " top:   #{layout.y}px;"      +
          " width: #{layout.width}px;"  + 
          " height:#{layout.height}px;" 

  scid  = characteristic.slug.to_s
= fields_for 'q' do |f|
  %span.characteristic{:id => scid, :style => style }

    = f.label characteristic.slug, characteristic.name 

    %span.value{:style => "left: #{layout.padding}px; #{element_style}"}
      - case characteristic.class


        - when BooleanCharacteristic
          :ruby 
            checked = characteristic.default
            options = {:checked => 'checked'}
            options[:class] = 'tristate'
            value = checked.nil? ? '' : (characteristic.default ? 'true' : 'false')
    
          = f.check_box characteristic.slug, options, value

        - when IntegerCharacteristic
          -if characteristic.ranged?
            = f.text_field "#{characteristic.slug}_greater_than", { :value => (q[scid + '_greater_than'] || characteristic.l_limit.to_i), 
                                                                    :min   => characteristic.l_limit.to_i, 
                                                                    :max   => characteristic.r_limit.to_i, 
                                                                    :step  => characteristic.step.to_i }
            &mdash;
            = f.text_field "#{characteristic.slug}_less_than", { :value => (q[scid + '_less_than'] || characteristic.l_limit.to_i), 
                                                                    :min   => characteristic.l_limit.to_i, 
                                                                    :max   => characteristic.r_limit.to_i, 
                                                                    :step  => characteristic.step.to_i }
          -else
            = f.text_field characteristic.slug, { :value => (q[scid] || characteristic.l_limit.to_i), 
                                                                    :min   => characteristic.l_limit.to_i, 
                                                                    :max   => characteristic.r_limit.to_i, 
                                                                    :step  => characteristic.step.to_i }
          = characteristic.measure
          %span.description= "(#{characteristic.description})" unless characteristic.description.nil? || characteristic.description.empty?


        - when FloatCharacteristic
          -if characteristic.ranged?
            = f.text_field "#{characteristic.slug}_greater_than", { :value => (q[scid + '_greater_than'] || characteristic.l_limit), 
                                                                    :min   => characteristic.l_limit, 
                                                                    :max   => characteristic.r_limit, 
                                                                    :step  => characteristic.step }
            &mdash;
            = f.text_field "#{characteristic.slug}_less_than", { :value => (q[scid + '_less_than'] || characteristic.l_limit), 
                                                                    :min   => characteristic.l_limit, 
                                                                    :max   => characteristic.r_limit, 
                                                                    :step  => characteristic.step }
          -else
            = f.text_field characteristic.slug, { :value => (q[scid] || characteristic.l_limit), 
                                                                    :min   => characteristic.l_limit, 
                                                                    :max   => characteristic.r_limit, 
                                                                    :step  => characteristic.step }
          = characteristic.measure
          %span.description= "(#{characteristic.description})" unless characteristic.description.nil? || characteristic.description.empty?


        - when SelectionCharacteristic
          - case characteristic.representation
            - when 'radiogroup'
              - characteristic.selection_options.each do |o|
                = radio_button_tag characteristic.slug, o.value, q[scid] == o.value
                = o.value

            - when 'selectbox'
              = select_tag characteristic.slug, 
                options_from_collection_for_select(characteristic.selection_options, "value", "value", q[scid]), 
                                 :include_blank => characteristic.includes_blank?


